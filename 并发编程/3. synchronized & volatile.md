# 2. synchronized & volatile
标签（空格分隔）： 并发编程
---
## **synchronized：同步**
同步的概念就是共享，我们要牢牢的记住“共享”这两个字，如果不是共享的资源，就没必要进行同步。
synchronized 关键字修饰的代码块或方法能够同时满足原子性和可见性，所以同步代码块或方法是线程安全的。

### **区分synchronized 获取的锁**：
在Java 中，每个Object 都会有一个监听器(monitor)，这个就是我们常说的synchronized 的锁，当线程获取到Object 的监听器时，就代表线程获取到了锁，可以进入进入同步代码块。
+ pubilc static synchronized method1(): 静态类的锁对象是 XXX.class 也称为类锁。
+ pubilc synchronized method1(): 普通方法的锁对象是 this。
+ synchronized(object){...} : 同步代码块的锁对象是指定的 object 对象。

我们需要明确的区分synchronized的锁对象，不然会造成死锁等异常状态：
```
public class TreeNode {
    TreeNode parent   = null; 
    List children = new ArrayList();
    public synchronized void addChild(TreeNode child){
        if(!this.children.contains(child)) {
            this.children.add(child);
            child.setParentOnly(this);
        }
    }
    public synchronized void addChildOnly(TreeNode child){
        if(!this.children.contains(child){
            this.children.add(child);
        }
    }
    public synchronized void setParent(TreeNode parent){
        this.parent = parent;
        parent.addChildOnly(this);
    }
    public synchronized void setParentOnly(TreeNode parent){
        this.parent = parent;
    }
}
```
假设执行下面的伪代码，Thread1 获取了 parent锁，在等待child锁； Thread2 获取了child锁，在等待parent锁，这时就造成了死锁现象。
```
Thread1: parent.addChild(chiled);  // locks parent
            ---> child.setParentOnly(parent);
Thread2: child.setParent(parent)  // locks child
            ---> parent.addChildOnly(child);
```
由于JVM并不会对死锁进行检测，所以在写同步代码时需要小心使用同步类，注意区分每个同步类锁获取的锁对象，以避免死锁等问题。单独的死锁问题的避免可以有 1. 控制加锁顺序 2.加锁时限 3.死锁检测 等方法来处理。

## **volatile**





