# 1. 线程
标签（空格分隔）： 并发编程
---
## **JLS 中是如何描述线程的？** 
### **线程**
在Java 中，线程使用Thread类表示的。对用户来说，创建线程的唯一方式就是创建这个类的的对象，每个线程都和一个这样的对象关联。线程在对相应的Thread 对象上调用 start() 方法时启动。
#### **同步**
同步(synchronized) 是Java 语言中最基础的线程间通信机制，它是使用`监视器(monitor)`实现的。在 JAVA 中每个对象都与一个线程可以锁定或解锁的监视器相关联(也就是说每个对象都有一个monitor)。在任何时刻，只有一个线程可以持有某个监视器上的锁。任何其它试图锁定该监视器的线程都将阻塞。
#### **等待集和通知**
每个对象除了拥有上述所说监视器，还拥有一个与线程相关联的`等待集`，即一个`线程集`。等待集只能通过 Object.wait(), Object.notify() 和 Object.notifyAll()进行操作。wait()就是将线程加入到等待集中；notify()就是移除等待集中一个线程； notifyAll()就是清空等待集。
#### **等待**
等待动作在调用wait()时，或调用具有定时机制的 wait(long millisecs)和 wait(long millisecs, int nanosecs) 时发生。
执行 wait 动作后，会将线程添加到对象的等待集中，若线程在执行wait之前还拥有n 个监视器的锁，则执行 n 次解锁动作（也就是`释放所有的锁资源`）。线程不执行任何更近一步的指令，直到它从等待集中移除。
以下动作可以将线程从等待集中移除：
1. 在对象上执行 notify
2. 在对象上执行 notifyAll
3. 在线程上执行 interrupt
4. 如果是定时等待，那么从等待动作开始至少 millisecs 毫秒加 nanosecs 纳秒的时间流逝后，一个内部动作会将线程从对象的等待集中移除。
#### **通知**    
通知动作发生在对 notify 和 notifyAll 进行调用时。
notify： 从等待集中移除一个线程，被移除的线程并不能立即获得对象监视器，被移除的线程会继续执行对监视器的争用。
notifyAll： 将所有线程从等待集中移除，被移除的线程所有线程都可以继续执行。
其中每次只能有一个线程可以锁定在等待继续的过程中所需的监视器。
#### **中断**
中断动作发生在对 Thread.interrupt 进行调用时， 以及发生在对定义为依次会调用它的方法进行调用时，例如 ThreadGroup.interrupt。
调用 interrupt 动作后会将线程的中断状态设置为 true 。
#### **睡眠和让步**
Thread.sleep 会导致当前运行的线程睡眠(暂时中止执行)指定的时间，具体时间取决于系统定时器和调度器的精度和准确度。睡眠的线程`不会丧失对任何监视器的所有权`，二继续执行的时机则依赖于执行该线程的处理器的调度机制和可用性。
Thread.yield 线程让步，建议具有相同优先级的其他线程可以运行，`不会丧失对任何监视器的所有权`。

## **线程状态的转换**
Java 语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，这5种状态分别如下：

+ 新建(New)： 创建后尚未启动的线程。
+ 运行(Runable)： Runable 包括操作系统线程状态中的 Running 和 Ready, 也就是处于此状态的线程有可能正在执行，也有可能正在等待CPU为它分配执行时间。
+ 无限期等待(Waiting)：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示地唤醒。以下方法会让线程陷入无限期的等待状态：
    + 没有设置Timeout 参数的 Object.wait() 方法。
    + 没有设置Timeout 参数的 Thread.join() 方法。
    + LockSupport.park()。
+ 期限等待(Timed Waiting)：处于这种状态的线程不会被分配CPU执行时间，不过无须等待被其它线程显示地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程陷入限期的等待状态：
    + Tthread.sleep() 方法。
    + 设置Timeout 参数的 Object.wait() 方法。
    + 设置Timeout 参数的 Thread.join() 方法。
    + LockSupport.parkNanos() 方法。
    + LockSupport.parkUntil() 方法。
+ 阻塞(Blocked)： 线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态” 则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。（在使用Lock的时候也会进入这种状态）
+ 结束(Terminated)：已终止线程的线程状态，线程已经结束执行。

![此处输入图片的描述][1]


  [1]: https://github.com/FarmerShao/treasure/blob/master/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png