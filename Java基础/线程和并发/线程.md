# 线程
---
## **线程**
### **JSL 对线程的定义**


### **线程的创建**
1. 继承 Thread 
    ```
    public class MyThread extends Thread {
        @Override
        public void run(){
            System.out.println("MyThread running");
        }
    }
    ```
    
2. Thread 匿名子类
    ```
    Thread t = new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println("MyThread running");
        }
    });
    ```
3. 实现 Runnable 接口
    
    ```
    public class MyThread implements Runnable {
        public void run(){
            System.out.println("MyThread running");
        }
    }
    ```
4. 个人的选择偏好：我个人比较喜欢使用实现 Runnable 接口来实现线程，主要有以下几点原因：
    1. Java 是单继承的，若继承了Thread 类后，类就不能继承其它类了。
    2. 一般定义线程，我关注的是线程所要运行的任务是什么，我不关心线程的其它属性；我个人任务实现Runnable 接口的类上都是指令/任务，交给线程做的指令/任务。

### **线程间的通信**
1. 在IO中可以使用 PipedInputStream/PipedOutStream，或是NIO的 Pipe 进行线程间的信息传输。
2. 可以使用 wait(),notify(),notifyAll()来进行线程间的通信。注： wait()  会释放锁资源，notify()&notifyAll() 不会释放所资源。
    2-1. 信号丢失问题：即当一个线程调用notify()时，没有线程在等待；当后续有线程进入等待时，却等不到这个notify()信号，而造成这个线程一直在等待。解决方案是将信号保存到信号类里。
    ```
    public class MyMonitor {
        private final Object myMonitorObject = new Object();
        private boolean wasSignalled = false;
        public void doWait(){
            synchronized(myMonitorObject){
                while(!wasSignalled){
                    try{
                        myMonitorObject.wait();
                    } catch(InterruptedException e){
                        System.out.println("Hey boy you have a exception");
                    }
                }
                wasSignalled = false;
            }
        }
    
        public void doNotify(){
            synchronized(myMonitorObject){
                wasSignalled = true;
                myMonitorObject.notify();
            }
        }
    }
    ```
    2-2. 不要在字符串常量或全局对象中调用wait()。
   
### **ThreadLocal**
ThreadLocal类可以让你创建的变量只被同一个线程进行读和写操作。因此，尽管有两个线程同时执行一段相同的代码，而且这段代码又有一个指向同一个ThreadLocal变量的引用，但是这两个线程依然不能看到彼此的ThreadLocal变量域。InheritableThreadLocal 是 ThreadLocal 的子类，允许一个线程创建的所有子线程访问其父线程的值。
```
ThreadLocal<Integer> threadLocal = new ThreadLocal<>();
//初始化值
threadLocal.set(10);
//取值
Integer integer = threadLocal.get();
```

## **线程池**
### **阻塞队列**
在说明线程池前，先说明一下线程池中需要用到的阻塞队列。

*什么是阻塞队列？*
阻塞队列就是 1.当队列为空时，获取元素的线程就会阻塞，等待队列为非空时，获取元素。2.当队列满了时，插入元素的线程就会阻塞，等待队列有空余位置插入元素。

***先来自己实现一个简单的阻塞队列***
```
public class MyBlockQueue<T> {

    private List<T> queue = new LinkedList<T>();
    private int capacity = 10;

    private final MyMonitor takeMonitor = new MyMonitor();
    private final MyMonitor addMonitor = new MyMonitor();

    public MyBlockQueue() {
    }

    public MyBlockQueue(int capacity) {
        this.capacity = capacity;
    }

    public void add(T obj) throws InterruptedException {
        synchronized(addMonitor){
            while (capacity == queue.size()) {
                addMonitor.doWait();
            }
            queue.add(obj);
            takeMonitor.doNotify();
        }
    }

    public T take() throws InterruptedException {
        synchronized(takeMonitor){
            while (queue.size() == 0){
                takeMonitor.doWait();
            }
            T t = queue.get(0);
            queue.remove(0);
            addMonitor.doNotify();
            return t;
        }
    }
}
```

***再来看JDK 实现的阻塞队列：***
|队列|功能|
|:--:|:--:|
|ArrayBlockingQueue|一个由数组结构组成的有界阻塞队列。|
|LinkedBlockingQueue|一个由链表结构组成的有界阻塞队列。|
|PriorityBlockingQueue|一个支持优先级排序的无界阻塞队列。|
|DelayQueue|一个使用优先级队列实现的无界阻塞队列。(元素需实现 Delayed 接口)|
|SynchronousQueue|一个不存储元素的阻塞队列。|
|LinkedTransferQueue|一个由链表结构组成的无界阻塞队列。|
|LinkedBlockingDeque|一个由链表结构组成的双向阻塞队列。|

### **创建线程池**
Java 中使用 ThreadPoolExecutor 类来创建自己想要的线程池：
```
public ThreadPoolExecutor(int corePoolSize,                         
                          int maximumPoolSize,                      
                          long keepAliveTime,                       
                          TimeUnit unit,                            
                          BlockingQueue<Runnable> workQueue,        
                          ThreadFactory threadFactory,              
                          RejectedExecutionHandler handler)         
```
|参数|解释|
|:--:|:--:|
|corePoolSize|核心线程数，不会被销毁的线程数|
|maximumPoolSize|线程池的最大线程数|
|keepAliveTime|超过corePoolSize 数的线程会在 keepAliveTime 的空闲时间后被销毁|
|unit|keepAliveTime 时间的单位|
|workQueue|存放任务(或叫指令)的队列|
|threadFactory|生产Thread 的工厂类|
|handler|拒绝任务的策略,当线程数达到最大值，且queue也满载后执行|
