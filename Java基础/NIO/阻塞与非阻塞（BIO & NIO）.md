# 阻塞与非阻塞（BIO & NIO）
---
    阻塞与非阻塞IO通道两者最大的区别在于它们是如何从底层的channel（socket或file）读取数据的。
    
    IO管道通常从流中读取数据（来自socket或者file）并且将这些数据拆分为一系列连贯的消息。将拆分数据流成消息这一组件称为“消息读取器”（Message Reader）下面是Message Reader拆分流为消息的示意图：
    
    Stream --> Message Reader --> Message --> Message ...
    

## **BIO**
一个阻塞IO管道可以使用类似InputStream的接口每次一个字节地从底层Channel读取数据，并且这个接口阻塞直到有数据可以读取。这就是阻塞式Message Reader的实现过程。

### **BIO的优点**
简化了Message Reader 的设计与实现，从不用处理在流没有数据可读的情况，或者它只读取流中的部分数据并且对于消息的恢复也要延迟处理的情况。
阻塞式Message Writer(一个将数据写入流中组件)也从不用处理只有部分数据被写入和写入消息要延迟恢复的情况

### **BIO的缺点**
`每一个要分解成消息的流都需要一个独立的线程。`
在高并发量下，维持大量的线程，将会消耗系统大量的内存；
可以使用线程池来改善线程数量的无限制上涨，将入站链接保存在一个队列中，线程按照进入队列的顺序处理入站链接。然而，这一设计需要入站链接合理地发送数据，否则若大量入站链接长时间不活跃，造成线程池中大量的线程阻塞，这样就会造成服务器响应速度变慢甚至不响应。若将线程池的线程数量设置为课动态扩展的，虽然能稍微的减缓上述情况带来的问题，但是机器的线程数量还是有上线的，并不能完美的解决上述问题。

## **NIO**
`一个非阻塞式的IO管道可以使用一个单独的线程读取多个流的数据。`
### **NIO的优点**
单线程可以处理多个流的数据。数据的读/写是非阻塞的，可以只为有数据准备读/写得流进行操作，即可以选择有效的流进行操作，提升资源的利用率，而不需像BIO一样即使没有数据，也要将线程阻塞等待。

### **NIO的缺点**
在数据读时：需要处理2个问题
    1. 判断否是能在数据包中获取完整的数据。
    2. 在其余消息到达之前如何处理已到达的部分消息。

## **非阻塞IO服务器设计思路**
+ 处理读部分数据：
    1. 每个 channel 单独使用一个 Message Reader 来解析消息。
    2. 定义消息传输的 protocol。
    3. 使用TLV(Type,Length,Value) encoding 信息，即为消息的头部加上消息体的长度和类型，最好是再设置一个超时时间，这样就能有效的减少那些慢连接大数据体的消息占用大量的内存所带来的问题，至少服务器是可以恢复的。即使是这样子，若是受到而已的 DoS 攻击还是很容易将内存给分配完
    4. 也可以使用“[通过复制调整大小][1]” 来处理消息的部分读。

+ 处理写部分
    1. 为每一个要写入的 channle 分配一个 Message Writer。
    2. 当一个完整的消息被写入Message Writer，Message Writer向Selector注册其相关Channel（如果尚未注册）。
    3. 当你的服务器有时间时，检查Selector以查看哪些注册的Channel实例已准备好进行写入。 对于每个写就绪Channel，请求其关联的Message Writer将数据写入Channel。如果Message Writer将其所有消息写入其Channel，则Channel将再次从Selector取消注册。

  [1]: http://ifeve.com/non-blocking-server/