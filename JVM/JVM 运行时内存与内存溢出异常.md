# JVM 运行时内存与内存溢出异常
---

## **一、运行时数据区(虚拟机规范定义):**
|数据区|说明|大小|存储|
|:--:|:--:|:--:|:--:|
|PC 寄存器|一个线程拥有一个PC寄存器|至少保证一个引用的大小|Method: 保存正在执行的字节码指令/ Native Method : undefined|
|Java 虚拟机栈|与线程同时创建，用于创建栈帧①；不需要保证是连续的；后来先出|可固定大小，也可动态扩展|存储局部变量和一些尚未算好的结果|
|Java 堆|虚拟机启动时创建，可供各个线程共享的运行时内存区域|可设置最大、最小值|类实例、数组对象(GC所管理的对象)|
|方法区|虚拟机启东市创建，可供各个线程共享的运行内存区域，堆得逻辑组成部分|可设置最大、最小值|每一个类的结构信息，例如：运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。|
|运行时常量池|在方法区中分配，在加载类和接口到虚拟机后创建；是class文件中每一个类或接口的常量池表(constant_pool table)的运行时表现|由数据量决定，受方法区大小影响|若干种不同的常量，例如字符串值和数值字面量|
|本地方法栈|与线程同时创建；用来支持native 发放(指使用Java以外的其他语言编写的方法)|可设置最大、最小值|--|

### **栈帧**：
栈帧是用来`存储数据`和`部分过程结果`的数据结构，同时也是用来处理`动态链接`、`方法返回值`和`异常分派`。
栈帧随着方法调用而创建，随着方法结束而摧毁--无论方法是正常完成还是异常完成(抛出了在方法内未被捕获的异常)都算作方法结束。
每一个栈帧都有自己的`本地变量表`、`操作数栈`和`指向当前方法所属的类的运行时常量池的引用`。
栈帧是线程本地私有的数据，不可能在一个栈帧之中引用另外一个线程的栈帧。

+ **局部变量表**：
每个栈帧内部都包含一组称为局部变量表的变量列表。栈帧中局部变量的长度由编译期决定，并且存储于类或接口的二进制表示之中，即通过方法的code属性保存及提供给栈帧使用。
一个局部变量可以保存一个类型为 boolean、byte、char、short、int、float、reference 或 returnAddress的数据。double 和 long 由2个局部变量保存。
第0个局部变量一定是保存实例方法所在对象的引用（即Java语言中的this关键字）。

+ **操作数栈**：
每个栈帧内部都包含一个称为操作数栈的`后进先出栈`。
栈帧在刚刚创建时，操作数栈时空的。Java 虚拟机提供一些字节码指令来从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中，也提供了一些指令用于从操作数栈中取走数据、操作数据以及把操作结果重新入栈。在调用方法时，操作数栈也用来准备调用方法的参数以及方法返回的结果。
操作数栈的每个位置上可以保存Java虚拟机中定义的任意数据类型的值，包括long 和 double。

+ **方法正常调用完成**：
方法调用完成后，当前栈帧承担这恢复调用者状态的责任，包括恢复调用者的局部变量表和操作数栈，以及正确的递增程序计数器，以跳过刚才执行的方法调用指令。
调用者的代码在被调用方法的返回值压入调用者栈帧的操作数栈后，会继续正常执行。

+ **方法异常调用完成**：
如果方法异常调用完成，那一定不会有方法返回值返回给其调用者。



## 参考资料
+ Java 虚拟机规范(Java SE 8版)